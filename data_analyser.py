import settings
from ast import literal_eval

STACK_TRACE_ITEM_POSITION_LINE_NUMBER = 1
STACK_TRACE_ITEM_POSITION_FUNCTION_CALL = 3


class StackTraceItem:
    def __init__(self):
        self.line_number_in_transformed_code = 0
        # TODO: replace with function name and arguments
        self.function_call = ""

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return "[StackTraceItem] line_number_in_transformed_code: " + str(self.line_number_in_transformed_code) + ", call: " + self.function_call


class DataLine:
    # TODO: replace with enum
    def __init__(self):
        self.data_type = None
        self.var_name = None
        self.data_value = None
        self.execution_order_number = 0
        self.stacktrace_items = []

    def __str__(self):
        stacktrace_string = ""
        for stactrace_item in self.stacktrace_items:
            stacktrace_string += "\n" + stactrace_item.__str__()
        return "[DataLine] type: " + str(self.data_type) + ", var_name: " + str(self.var_name) + ", execution_order: " + str(self.execution_order_number) + str(stacktrace_string)

    def __repr__(self):
        return self.__str__()


def analyse_collected_data(generated_data_filename):
    collected_data = open(generated_data_filename, "r")

    execution_order_number = 1
    parsed_data_lines = []
    for line in collected_data:
        data_line = parse_data_line(line, execution_order_number)
        parsed_data_lines.append(data_line)
        execution_order_number += 1

    for data_line in parsed_data_lines:
        print "\n" + str(data_line)


def parse_data_line(line, execution_order_number):
    data_line = DataLine()
    if line.startswith(settings.META_MARK_VARCHANGE):
        filtered_data_string = line.replace(settings.META_MARK_VARCHANGE, "")
        splitter_position = filtered_data_string.find("=")
        var_name = filtered_data_string[:splitter_position - 1]
        filtered_data_string = filtered_data_string[splitter_position + 1:]

        data_line.data_type = settings.META_MARK_VARCHANGE
        data_line.var_name = var_name
        data_line.data_value = literal_eval(filtered_data_string)
    elif line.startswith(settings.META_MARK_STACKTRACE):
        filtered_data_string = line.replace(settings.META_MARK_STACKTRACE, "")

        data_line.data_type = settings.META_MARK_STACKTRACE
        data_line.data_value = literal_eval(filtered_data_string)
        data_line.stacktrace_items = process_stacktrace_info(data_line.data_value)
    data_line.execution_order_number = execution_order_number
    return data_line


def process_stacktrace_info(stack_trace):
    stack_trace_items = []
    for stack_trace_item in stack_trace:
        if stack_trace_item:
            if stack_trace_item[0] == settings.TRANSFORMED_SOURCE_FILE:
                stack_trace_item_structure = StackTraceItem()

                position = 0
                for attribute in stack_trace_item:
                    if position == STACK_TRACE_ITEM_POSITION_LINE_NUMBER:
                        stack_trace_item_structure.line_number_in_transformed_code = attribute
                    elif position == STACK_TRACE_ITEM_POSITION_FUNCTION_CALL:
                        stack_trace_item_structure.function_call = attribute
                    position += 1

                # To remove useless function call generated by the Luminous-tool
                if stack_trace_item_structure.function_call.startswith(settings.FILE_DESCRIPTOR_NAME) == False:
                    stack_trace_items.append(stack_trace_item_structure)
    return stack_trace_items